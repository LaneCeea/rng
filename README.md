# Random Number Generation

In Standard C, the only RNG utility available is `rand` and `srand` inside `stdlib.h`. One often finds the following code snippet in tutorials on how to generate random numbers within a range:

```c
srand(time(NULL));
int x = lower + rand() % (upper - lower + 1);
```
This is, however, biased and not reliable at all. As the [cppreference](https://en.cppreference.com/w/c/numeric/random/rand) website states:

> There are no guarantees as to the quality of the random sequence produced. In the past, some implementations of `rand()` have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between 1 and 0 between calls). `rand()` is not recommended for serious random-number generation needs, like cryptography.

Furthermore, not only does `rand` lack quality, it also suffers from poor performance. One should never use them in practice except for learning purposes.

Given this limitations, developers need better alternatives. The world of pseudorandom number generation (PRNG) offers many high-quality algorithms, with different trade-offs in terms of speed, period, and quality etc. However, these algorithms often come with inconsistent interfaces, making it difficult to experiment with different PRNGs or switch between them in applications.

Therefore, this project aims to establish the three main goals:
**1.** Create an interface for renowned PRNG algorithms, and learn to develop one.
**2.** Implement common distribution functions.
**3.** Implement statistical tests to measure the quality of the combined RNG engine.

---

## PRNG

The design philosophy centers on *simplicity* in C, and *abstraction* in C++. This dual approach emerged from recognizing the different strengths and limitations between C and C++ when it comes to creating reusable interfaces.

#### Simplicity in C

The C implementation is focused on accomplishing a minimal yet consistent interfaces across all PRNG algorithms. Each algorithm is self-contained. One can simply drop the `{prng}.h` and `{prng}.c` files onto any project and start using them.

The header file of each PRNG algorithm follows this standardized design:

```c
#define PRNG_MIN 0U
#define PRNG_MAX /* maximum possible value */

typedef struct {
    /* internal state */
} prng_t;

////////////////////////////////////////
// use the state passed in by user 
////////////////////////////////////////

// initialize the internal state
void prng_seed(prng_t* prng, uint64_t s1, uint64_t s2);

// get the pseudorandom number
uint32_t prng_rand(prng_t* prng);

////////////////////////////////////////
// use the global state inside prng.c
////////////////////////////////////////

void prng_seed_g(uint64_t s1, uint64_t s2);
uint32_t prng_rand_g(void);
```

This interface design makes sense because PRNGs are fundamentally simple: they need an internal state and two core functions to operate. Thus, we can create a unified way to work with different algorithms.

The available PRNG algorithms are:

| PRNG | Description |
| :---: | :--- |
| `standard` | using `srand` and `rand` from Standard C |
| `mt19937` | check their [official website](https://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/MT2002/emt19937ar.html) |
| `pcg32` | check their [official website](https://www.pcg-random.org/index.html) |
| `xoshiro128plusplus` | check their [official website](https://prng.di.unimi.it/) |
| `chatgpt` | generated by ChatGPT-o3 |

#### Abstraction in C++

While the C implementation provides consistency, it does not solve the abstraction problem - how does one write a function that can work with *any* PRNG algorithm without writing boilerplate code for each one?

In C, one could theoretically achieve this using `void*` pointer:

```c
void prng_seed(void* prng_t, uint64_t s1, uint64_t s2);
uint32_t prng_rand(void* prng_t);
```

However, this approach sacrifices type safety and requires runtime conversions, which goes agianst the goal of creating clean and efficient interfaces.

The C++ wrapper `prng.hpp` solves this issue through compile-time abstraction using C++20 concepts. The `PRNG` concept allows function templates to work with any PRNG algorithm while maintaining type safety and performance:

```cpp
template <PRNG PrngT>
uint32_t Test(uint64_t s1, uint64_t s2) {
    PrngT Prng(s1, s2);
    return Prng.Rand();
}
```

This approach is chosen over OOP inheritance (which would involve virtual functions and runtime dispatch) in favor of compile-time polymorphism. C++20 concepts provide a much cleaner syntax compared to the template metaprogramming techniques like SFINAE that were necessary in earlier C++ standards.

---

## Distribution

- `ContinuousUniform`
- `Normal`
- `Exponential`

---

## Test

---

## Prerequisites
- **Standard**: C11, C++20
- **Build System**: CMake

## Building
```bash
mkdir build
cd build
cmake ..
cmake --build .
```